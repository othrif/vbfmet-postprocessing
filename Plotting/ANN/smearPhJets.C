
//
// Sorting algorithm
//
struct SortPhysicsObject {
  
  SortPhysicsObject(const std::string &key = "") :fKey(key) {}
  
  //template<class M, class T>
  bool operator()(const TLorentzVector &lhs, const TLorentzVector &rhs) const{
    //
    // Sort based on pt 
    //
    return lhs.Pt() > rhs.Pt();
  }
  bool operator()(const TVector3       &lhs, const TVector3       &rhs) const{
    //
    // Sort based on pt 
    //
    return lhs.Pt() > rhs.Pt();
  }
  
public:
  
  std::string fKey;
};

//----
void correctMET(TVector3 &metv, TLorentzVector jetv,bool add){
  TVector3 jetvm = jetv.Vect();
  if(add){
    metv+=jetvm;
  }else{
    metv-=jetvm;
  }
}

float smearWidth(float pt, float eta){
  if(fabs(eta)>2.5) return 4.0e3;
  return 3.0e3;

}

bool passMETSelection(TLorentzVector jet, float jvt){
  if(jet.Pt()<20e3) return false;
  if(fabs(jet.Eta())>2.4) return true;
  if(fabs(jvt)<=0.5 && jet.Pt()<60e3) return false;
  return true;
}

void smearPhJets(std::string treeNmae="SinglePhoton",std::string period="A") {
  // Example of Root macro to copy a subset of a Tree to a new Tree
  // Only selected entries are copied to the new Tree.
  // The input file has been generated by the program in $ROOTSYS/test/Event
  // with   Event 1000 1 99 1
  //Author: Rene Brun
  
  //Get old file, old tree and set top branch address
  std::string oldfileNmae="/tmp/"+treeNmae+"Nominal364541.root";
  TFile *oldfile = new TFile(oldfileNmae.c_str());
  std::cout << "File: " << oldfile << std::endl;
  std::string oldtreeNmae=treeNmae+"Nominal";
  TTree *oldtree = (TTree*)oldfile->Get(oldtreeNmae.c_str());
  std::cout << "Tree: " << oldtree << " " << oldtreeNmae << std::endl;  
  Long64_t nentries = oldtree->GetEntries();

  // turn off weights
  for(const auto &pleaf : *(oldtree->GetListOfLeaves())){
    std::string leafName = pleaf->GetName();
    if(leafName.size()>1 && leafName[0]==string("w")){
      oldtree->SetBranchStatus(leafName.c_str(),0);
      std::cout << "Turned off: " << leafName << std::endl;
    }
  }

  TRandom3 m_rand;

  std::vector<float> copy_el_pt;
  std::vector<float> copy_el_phi;
  std::vector<float> copy_el_eta;
  std::vector<float> copy_baseel_pt;
  std::vector<float> copy_baseel_phi;
  std::vector<float> copy_baseel_eta;
  
  std::vector<float> *el_pt=new std::vector<float>();
  std::vector<float> *el_phi=new std::vector<float>();  
  std::vector<float> *el_eta=new std::vector<float>();
  std::vector<float> *baseel_pt=new std::vector<float>();
  std::vector<float> *baseel_phi=new std::vector<float>();  
  std::vector<float> *baseel_eta=new std::vector<float>(); 
  std::vector<float> *ph_phi=new std::vector<float>();
  std::vector<float> *ph_eta=new std::vector<float>();
  std::vector<float> *ph_pt=new std::vector<float>();
  std::vector<float> *jet_phi=new std::vector<float>();
  std::vector<float> *jet_eta=new std::vector<float>();
  std::vector<float> *jet_pt=new std::vector<float>();
  std::vector<float> *jet_m=new std::vector<float>();
  std::vector<float> *jet_jvt=new std::vector<float>();

  std::vector<float> *basejet_phi=new std::vector<float>();
  std::vector<float> *basejet_eta=new std::vector<float>();
  std::vector<float> *basejet_pt=new std::vector<float>();
  std::vector<float> *basejet_m=new std::vector<float>();
  std::vector<float> *basejet_jvt=new std::vector<float>();  
  int runNumber   = 0;
  int n_baseel   = 0;
  int n_el   = 0;
  int n_el_w   = 0;
  int n_ph   = 0;
  int n_basemu   = 0;
  float met_truth_et=0;
  float met_tst_et=0;
  double met_cst_jet=0;  
  float met_cst_phi=0;  
  float met_tst_nolep_et=0;
  float met_tst_phi=0;
  float met_tst_nolep_phi=0;  
  float SherpaVTruthPt=0;
  float truth_V_dressed_pt=0;
  double truth_jj_mass=0;
  double jj_mass=0.0;
  double jj_dphi=0.0;
  double jj_deta=0.0;
  int n_jet=0;
  float w=0.0;
  double met_tst_j1_dphi =0;
  double met_tst_j2_dphi =0;
  double met_tst_nolep_j1_dphi =0;
  double met_tst_nolep_j2_dphi =0;  
  oldtree->SetBranchAddress("w",&w);
  oldtree->SetBranchAddress("runNumber",&runNumber);
  oldtree->SetBranchAddress("n_baseel",&n_baseel);
  oldtree->SetBranchAddress("n_el",&n_el);
  oldtree->SetBranchAddress("n_ph",&n_ph);
  oldtree->SetBranchAddress("el_pt",&el_pt);
  oldtree->SetBranchAddress("el_eta",&el_eta);
  oldtree->SetBranchAddress("el_phi",&el_phi);
  oldtree->SetBranchAddress("baseel_pt",&baseel_pt);
  oldtree->SetBranchAddress("baseel_eta",&baseel_eta);
  oldtree->SetBranchAddress("baseel_phi",&baseel_phi);
  
  oldtree->SetBranchAddress("jet_pt",&jet_pt);
  oldtree->SetBranchAddress("jet_eta",&jet_eta);
  oldtree->SetBranchAddress("jet_phi",&jet_phi);
  oldtree->SetBranchAddress("jet_m",&jet_m);
  oldtree->SetBranchAddress("jet_jvt",&jet_jvt);
  oldtree->SetBranchAddress("basejet_pt", &basejet_pt);
  oldtree->SetBranchAddress("basejet_eta",&basejet_eta);
  oldtree->SetBranchAddress("basejet_phi",&basejet_phi);
  oldtree->SetBranchAddress("basejet_m",  &basejet_m);
  oldtree->SetBranchAddress("basejet_jvt",&basejet_jvt);
  
  oldtree->SetBranchAddress("met_tst_j1_dphi",&met_tst_j1_dphi);
  oldtree->SetBranchAddress("met_tst_j2_dphi",&met_tst_j2_dphi);
  oldtree->SetBranchAddress("met_tst_nolep_j1_dphi",&met_tst_nolep_j1_dphi);
  oldtree->SetBranchAddress("met_tst_nolep_j2_dphi",&met_tst_nolep_j2_dphi);  
  
  oldtree->SetBranchAddress("ph_pt",&ph_pt);
  oldtree->SetBranchAddress("ph_eta",&ph_eta);
  oldtree->SetBranchAddress("ph_phi",&ph_phi);
  oldtree->SetBranchAddress("n_el_w",&n_el_w);
  oldtree->SetBranchAddress("n_basemu",&n_basemu);
  oldtree->SetBranchAddress("met_truth_et",&met_truth_et);
  oldtree->SetBranchAddress("met_tst_et",&met_tst_et);
  oldtree->SetBranchAddress("met_cst_jet",&met_cst_jet);
  oldtree->SetBranchAddress("met_cst_phi",&met_cst_phi);
  oldtree->SetBranchAddress("met_tst_nolep_et",&met_tst_nolep_et);
  oldtree->SetBranchAddress("met_tst_phi",&met_tst_phi);
  oldtree->SetBranchAddress("met_tst_nolep_phi",&met_tst_nolep_phi);
  oldtree->SetBranchAddress("jj_mass",&jj_mass);
  oldtree->SetBranchAddress("jj_deta",&jj_deta);
  oldtree->SetBranchAddress("jj_dphi",&jj_dphi);
  oldtree->SetBranchAddress("n_jet",&n_jet);
  
  oldtree->SetBranchAddress("truth_jj_mass",&truth_jj_mass);
  oldtree->SetBranchAddress("truth_V_dressed_pt",&truth_V_dressed_pt);
  oldtree->SetBranchAddress("SherpaVTruthPt",&SherpaVTruthPt);

  //Create a new file + a clone of old tree in new file
  std::string outfileName="/tmp/small"+treeNmae+".root";
  TFile *newfile = new TFile(outfileName.c_str(),"recreate");
  TTree *newtree = oldtree->CloneTree(0);
  //newtree->SetName("SmearPhJetsNominal");
  //newtree->SetTitle("SmearPhJetsNominal");
  newtree->SetName("SinglePhotonNominal");
  newtree->SetTitle("SinglePhotonNominal");
  TH1F *cutflow = new TH1F("cutflow","cutflow",15,0.5,15.5);
  cutflow->SetDirectory(newfile);
  
  bool debug=false;
  unsigned nSamples=20;
  TVector3 met_before,met_nolep_before,newel,met_after,met_nolep_after,met_cst_before,met_cst_after;
  TLorentzVector tmptvl,smeared_jet_bit,jet1,jet2;
  std::vector<TLorentzVector> alljetvec_before, alljetvec_after;
  std::vector<float> jvt,jvt_after;
  std::vector<bool> passMETCuts;
  std::cout << "setting seed: " << runNumber << std::endl;
  int periodSeed=0;
  if(period=="D") periodSeed=10;
  else if(period=="E") periodSeed=20;
  m_rand.SetSeed(runNumber+periodSeed);
  for (Long64_t i=0;i<nentries; i++) {
    if((i%10000)==0) std::cout <<"evt: " << i << std::endl;
    oldtree->GetEntry(i);
    cutflow->Fill(1);
    cutflow->Fill(2,w);
    if (n_ph==1 && n_el==0 && n_el_w==0 && n_baseel==0){
      
      //divide by the number of smearings
      w/=float(nSamples);

      // Load the jet vectors
      alljetvec_before.clear();
      for(unsigned ijet=0; ijet<jet_pt->size(); ++ijet){
	tmptvl.SetPtEtaPhiM(jet_pt->at(ijet),jet_eta->at(ijet), jet_phi->at(ijet), jet_m->at(ijet));
	alljetvec_before.push_back(tmptvl);
	jvt.push_back(jet_jvt->at(ijet));
	passMETCuts.push_back(passMETSelection(tmptvl,jet_jvt->at(ijet)));
      }
      if(debug) std::cout << "filled jet" << std::endl;      
      for(unsigned ijet=0; ijet<basejet_pt->size(); ++ijet){
	tmptvl.SetPtEtaPhiM(basejet_pt->at(ijet),basejet_eta->at(ijet), basejet_phi->at(ijet), basejet_m->at(ijet));
	alljetvec_before.push_back(tmptvl);
	jvt.push_back(basejet_jvt->at(ijet));
	passMETCuts.push_back(passMETSelection(tmptvl,basejet_jvt->at(ijet)));	
      }
      if(debug) std::cout << "filled basejet" << std::endl;
      // clear the base jets as they really are not useful in the smeared versions
      basejet_pt->clear();
      basejet_eta->clear();
      basejet_phi->clear();
      basejet_m->clear();
      basejet_jvt->clear();

      // set variables before smearing
      met_before.SetPtEtaPhi(met_tst_et,0.0,met_tst_phi);
      met_cst_before.SetPtEtaPhi(met_cst_jet,0.0,met_cst_phi);      
      met_nolep_before.SetPtEtaPhi(met_tst_nolep_et,0.0,met_tst_nolep_phi);
      
      // run the smearing
      for(unsigned sample=0; sample<nSamples; ++sample){
	alljetvec_after.clear();
	if(debug) std::cout << "sample: " << sample << std::endl;
	// smear jets
	for(unsigned ijet=0;ijet<alljetvec_before.size(); ++ijet){
	  tmptvl=alljetvec_before.at(ijet);
	  // apply the smearing
	  float energy_smear = m_rand.Gaus(0.0,smearWidth(tmptvl.Pt(),tmptvl.Eta()));
	  float rand_deta = m_rand.Gaus(0.0,0.05);	  
	  float rand_dphi = m_rand.Gaus(0.0,0.05);	  
	  smeared_jet_bit.SetPtEtaPhiM( fabs(energy_smear), tmptvl.Eta()+rand_deta, tmptvl.Phi()+rand_dphi, 0.0); // currently just a pT & energy change & jet angle. not changing the mass
	  if(energy_smear>0.0) tmptvl+=smeared_jet_bit;
	  else                 tmptvl-=smeared_jet_bit;
	  alljetvec_after.push_back(tmptvl);
	  if(debug){ std::cout << "jet before: " << alljetvec_before.at(ijet).Pt() << "  after: " << tmptvl.Pt() << std::endl; }
	}
	if(debug) std::cout << "smeared jets done " << std::endl;
	
	// update the MET
	met_after=met_before;
	met_cst_after=met_cst_before;	
	met_nolep_after=met_nolep_before;
	for(unsigned ijet=0;ijet<alljetvec_after.size(); ++ijet){
	  bool newJetPassMETSel = passMETSelection(alljetvec_after.at(ijet), jvt.at(ijet));
	  if(passMETCuts.at(ijet) && !newJetPassMETSel){
	    correctMET(met_after, alljetvec_before.at(ijet), true); // remove old jet. so add it back
	    correctMET(met_nolep_after, alljetvec_before.at(ijet), true); // remove old jet. so add it back
	  }else if(!passMETCuts.at(ijet) && newJetPassMETSel){
	    correctMET(met_after, alljetvec_after.at(ijet), false); // subtract it. negative vector sum jazz
	    correctMET(met_nolep_after, alljetvec_after.at(ijet), false); // subtract it. negative vector sum jazz
	  }else if(passMETCuts.at(ijet) && newJetPassMETSel){
	    correctMET(met_after, alljetvec_before.at(ijet), true); // remove old jet. so add it back
	    correctMET(met_after, alljetvec_after.at(ijet), false); // subtract it. negative vector sum jazz
	    correctMET(met_nolep_after, alljetvec_before.at(ijet), true); // remove old jet. so add it back
	    correctMET(met_nolep_after, alljetvec_after.at(ijet), false); // subtract it. negative vector sum jazz	    
	  }
	  // do the vector sum of all jets
	  bool passCSTBefore = alljetvec_before.at(ijet).Pt()>20e3;
	  bool passCSTAfter = alljetvec_after.at(ijet).Pt()>20e3;
	  if(passCSTBefore && !passCSTAfter){
	    correctMET(met_after, alljetvec_before.at(ijet), true); // remove old jet. so add it back
	  }else if(!passCSTBefore && passCSTAfter){
	    correctMET(met_after, alljetvec_after.at(ijet), false); // subtract it. negative vector sum jazz
	  }else if(passCSTBefore && passCSTAfter){
	    correctMET(met_cst_after, alljetvec_before.at(ijet), true); // remove old jet. so add it back
	    correctMET(met_cst_after, alljetvec_after.at(ijet), false); // subtract it. negative vector sum jazz
	  }
	}// end correcting the MET
	if(debug) std::cout << "update met done " << std::endl;
	
	// count jets. doing this by removing those that don't pass cuts
	jet_jvt->clear();
	for(unsigned ijet=0;ijet<alljetvec_after.size(); ++ijet){
	  if(alljetvec_after.at(ijet).Pt()<25.0e3){
	    alljetvec_after.erase(alljetvec_after.begin()+ijet);
	    --ijet;
	    continue;
	  }
	  else if(alljetvec_after.at(ijet).Pt()<60.0e3 && fabs(alljetvec_after.at(ijet).Eta())<2.4 && jvt.at(ijet)<0.11){
	    alljetvec_after.erase(alljetvec_after.begin()+ijet);
	    --ijet;
	    continue;
	  }
	  jet_jvt->push_back(jvt.at(ijet)); // not quite correct as the jet jvt was not sorted. can deal with it later
	}
	
	std::sort(alljetvec_after.begin(),alljetvec_after.end(),SortPhysicsObject("pt"));
	// set new variables
	jet_pt->clear();
	jet_eta->clear();
	jet_phi->clear();
	jet_m->clear();
	for(unsigned ijet=0;ijet<alljetvec_after.size(); ++ijet){
	  jet_pt->push_back(alljetvec_after.at(ijet).Pt());
	  jet_eta->push_back(alljetvec_after.at(ijet).Eta());
	  jet_phi->push_back(alljetvec_after.at(ijet).Phi());
	  jet_m->push_back(alljetvec_after.at(ijet).M());
	}
	jj_mass=0.0;
	jj_deta=0.0;
	jj_dphi=0.0;
	n_jet=alljetvec_after.size();
	
	met_tst_et=met_after.Pt();
	met_tst_phi=met_after.Phi();
	met_tst_nolep_et=met_nolep_after.Pt();
	met_tst_nolep_phi=met_nolep_after.Phi();
	if(alljetvec_after.size()>1){
	  jet1=alljetvec_after.at(0);
	  jet2=alljetvec_after.at(1);
	  met_tst_j1_dphi=fabs(jet1.Vect().DeltaPhi(met_after));
	  met_tst_j2_dphi=fabs(jet2.Vect().DeltaPhi(met_after));
	  met_tst_nolep_j1_dphi=fabs(jet1.Vect().DeltaPhi(met_nolep_after));
	  met_tst_nolep_j2_dphi=fabs(jet2.Vect().DeltaPhi(met_nolep_after));
	  jj_dphi = fabs(jet1.DeltaPhi(jet2));
	  jj_deta = fabs(jet1.Eta() - jet2.Eta());
	  jj_mass = (jet1 + jet2).M();
	}
	if(debug){
	  std::cout << "njet: " << n_jet << std::endl;
	  if(n_jet>1)
	    std::cout << "lead jet pT: " << jet_pt->at(0) << " sublead jet pT: " << jet_pt->at(1) << endl
		      << "   mjj: " << jj_mass << " detajj: " << jj_deta << endl
		      << "   met: " << met_tst_et << " met nolepton: " << met_tst_nolep_et
		      << std::endl;
	}

	// remove small numbers of jets
	cutflow->Fill(3,w);
	if(n_jet<2) continue;
	cutflow->Fill(4,w);
	if(jet_pt->at(0)<60e3) continue;
	cutflow->Fill(5,w);
	if(jet_pt->at(1)<40e3) continue;
	cutflow->Fill(6,w);
	if(jj_mass<250e3) continue;
	cutflow->Fill(7,w);
	if(met_tst_et<100e3 && met_tst_nolep_et<100e3) continue;
	cutflow->Fill(8,w);
	// filling for each smearing
	newtree->Fill();
      }
    }
    //event->Clear();
  }
  newtree->Print();
  newtree->AutoSave();
  cutflow->Write();
  newfile->Close();
  oldfile->Close();
  delete oldfile;
  delete newfile;
}
